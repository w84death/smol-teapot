#include <furi.h>
#include <gui/gui.h>
#include <input/input.h>
#include <stdlib.h>
#include <math.h>
#include <furi_hal_resources.h>

/* generated by fbt from .png files in images folder */
#include <p1x_smol_teapot_icons.h>

/* include triangulated teapot model */
#include "teapot.h"

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define PROJECTION_DISTANCE 150
#define FRAME_INTERVAL 50 // Increased to reduce processing load
#define MAX_TRIANGLES_PER_FRAME 400 // Limit triangles processed per frame

typedef struct {
    float x, y, z;
} Vec3f;

typedef struct {
    float m[4][4];
} Matrix4x4;

// Model state
static Vec3f rotation = {0};
static Vec3f position = {0, 0, 30}; // Moved camera farther back
static float scale = 2.0f; // Smaller scale for the triangulated teapot
static uint32_t last_frame_time = 0; // For frame rate limiting
static int current_triangle_batch = 0; // For triangle batching

// Function prototypes
static void render_frame(Canvas* canvas);
static void init_identity_matrix(Matrix4x4* m);
static void rotate_x_matrix(Matrix4x4* m, float angle);
static void rotate_y_matrix(Matrix4x4* m, float angle);
static void rotate_z_matrix(Matrix4x4* m, float angle);
static void multiply_matrix_vector(Matrix4x4* m, Vec3f* in, Vec3f* out);
static float dot_product(Vec3f* v1, Vec3f* v2);
static void cross_product(Vec3f* v1, Vec3f* v2, Vec3f* result);
static void subtract_vectors(Vec3f* v1, Vec3f* v2, Vec3f* result);

// App state
typedef struct {
    FuriMutex* mutex;
} TeapotState;

// Input callback function
static void input_callback(InputEvent* input_event, void* ctx) {
    furi_assert(ctx);
    FuriMessageQueue* event_queue = ctx;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

// Draw callback function
static void render_callback(Canvas* canvas, void* ctx) {
    furi_assert(ctx);
    TeapotState* state = ctx;
    
    if(furi_mutex_acquire(state->mutex, 100) != FuriStatusOk) return;
    
    canvas_clear(canvas);
    canvas_set_color(canvas, ColorBlack);
    
    // Render our 3D scene
    render_frame(canvas);

    // Display controls
    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str(canvas, 2, 62, "Smol Teapot 3D");
    
    furi_mutex_release(state->mutex);
}

// Simple 3D math functions
static void init_identity_matrix(Matrix4x4* m) {
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            m->m[i][j] = (i == j) ? 1.0f : 0.0f;
        }
    }
}

static void rotate_x_matrix(Matrix4x4* m, float angle) {
    m->m[1][1] = cosf(angle);
    m->m[1][2] = -sinf(angle);
    m->m[2][1] = sinf(angle);
    m->m[2][2] = cosf(angle);
}

static void rotate_y_matrix(Matrix4x4* m, float angle) {
    m->m[0][0] = cosf(angle);
    m->m[0][2] = sinf(angle);
    m->m[2][0] = -sinf(angle);
    m->m[2][2] = cosf(angle);
}

static void rotate_z_matrix(Matrix4x4* m, float angle) {
    m->m[0][0] = cosf(angle);
    m->m[0][1] = -sinf(angle);
    m->m[1][0] = sinf(angle);
    m->m[1][1] = cosf(angle);
}

static void multiply_matrix_vector(Matrix4x4* m, Vec3f* in, Vec3f* out) {
    out->x = in->x * m->m[0][0] + in->y * m->m[1][0] + in->z * m->m[2][0] + m->m[3][0];
    out->y = in->x * m->m[0][1] + in->y * m->m[1][1] + in->z * m->m[2][1] + m->m[3][1];
    out->z = in->x * m->m[0][2] + in->y * m->m[1][2] + in->z * m->m[2][2] + m->m[3][2];
    float w = in->x * m->m[0][3] + in->y * m->m[1][3] + in->z * m->m[2][3] + m->m[3][3];
    
    if(w != 0.0f) {
        out->x /= w;
        out->y /= w;
        out->z /= w;
    }
}

static float dot_product(Vec3f* v1, Vec3f* v2) {
    return v1->x * v2->x + v1->y * v2->y + v1->z * v2->z;
}

static void cross_product(Vec3f* v1, Vec3f* v2, Vec3f* result) {
    result->x = v1->y * v2->z - v1->z * v2->y;
    result->y = v1->z * v2->x - v1->x * v2->z;
    result->z = v1->x * v2->y - v1->y * v2->x;
}

static void subtract_vectors(Vec3f* v1, Vec3f* v2, Vec3f* result) {
    result->x = v1->x - v2->x;
    result->y = v1->y - v2->y;
    result->z = v1->z - v2->z;
}

static void render_frame(Canvas* canvas) {
    // Create rotation matrices
    Matrix4x4 rot_x_matrix, rot_y_matrix, rot_z_matrix;
    
    init_identity_matrix(&rot_x_matrix);
    init_identity_matrix(&rot_y_matrix);
    init_identity_matrix(&rot_z_matrix);
    
    rotate_x_matrix(&rot_x_matrix, rotation.x);
    rotate_y_matrix(&rot_y_matrix, rotation.y);
    rotate_z_matrix(&rot_z_matrix, rotation.z);
    
    // Calculate the start and end indices for this batch of triangles
    int start_triangle = current_triangle_batch * MAX_TRIANGLES_PER_FRAME;
    int end_triangle = start_triangle + MAX_TRIANGLES_PER_FRAME;
    
    // Make sure we don't exceed the number of triangles
    if(end_triangle > TEAPOT_TRIANGLE_COUNT) {
        end_triangle = TEAPOT_TRIANGLE_COUNT;
    }
    
    // Update the batch for the next frame
    current_triangle_batch++;
    if(current_triangle_batch * MAX_TRIANGLES_PER_FRAME >= TEAPOT_TRIANGLE_COUNT) {
        current_triangle_batch = 0;
    }
    
    // Process each triangle in the current batch
    for(int i = start_triangle; i < end_triangle; i++) {
        // Extract the triangle vertices from the array
        Vec3f v1 = {
            teapot_triangles[i * 9 + 0],
            teapot_triangles[i * 9 + 1],
            teapot_triangles[i * 9 + 2]
        };
        
        Vec3f v2 = {
            teapot_triangles[i * 9 + 3],
            teapot_triangles[i * 9 + 4],
            teapot_triangles[i * 9 + 5]
        };
        
        Vec3f v3 = {
            teapot_triangles[i * 9 + 6],
            teapot_triangles[i * 9 + 7],
            teapot_triangles[i * 9 + 8]
        };
        
        // Transform vertices
        Vec3f tv1, tv2, tv3;
        Vec3f temp;
        
        // Apply rotation matrices to v1
        multiply_matrix_vector(&rot_x_matrix, &v1, &temp);
        multiply_matrix_vector(&rot_y_matrix, &temp, &temp);
        multiply_matrix_vector(&rot_z_matrix, &temp, &temp);
        tv1.x = temp.x * scale + position.x;
        tv1.y = temp.y * scale + position.y;
        tv1.z = temp.z * scale + position.z;
        
        // Apply rotation matrices to v2
        multiply_matrix_vector(&rot_x_matrix, &v2, &temp);
        multiply_matrix_vector(&rot_y_matrix, &temp, &temp);
        multiply_matrix_vector(&rot_z_matrix, &temp, &temp);
        tv2.x = temp.x * scale + position.x;
        tv2.y = temp.y * scale + position.y;
        tv2.z = temp.z * scale + position.z;
        
        // Apply rotation matrices to v3
        multiply_matrix_vector(&rot_x_matrix, &v3, &temp);
        multiply_matrix_vector(&rot_y_matrix, &temp, &temp);
        multiply_matrix_vector(&rot_z_matrix, &temp, &temp);
        tv3.x = temp.x * scale + position.x;
        tv3.y = temp.y * scale + position.y;
        tv3.z = temp.z * scale + position.z;
        
        // Skip triangles with vertices too close to camera
        if(tv1.z < 1.0f || tv2.z < 1.0f || tv3.z < 1.0f) {
            continue;
        }
        
        // Calculate normal using cross product for backface culling
        Vec3f line1, line2, normal;
        subtract_vectors(&tv2, &tv1, &line1);
        subtract_vectors(&tv3, &tv1, &line2);
        cross_product(&line1, &line2, &normal);
        
        // Calculate dot product with camera direction (towards negative z)
        Vec3f camera_dir = {0, 0, 1};
        float dot = dot_product(&normal, &camera_dir);
        
        // Only render if facing camera (backface culling)
        if(dot < 0) {
            // Project the vertices to screen space
            // Note: Inverting Y-axis by using negative value to fix upside-down camera
            int x1 = (int)((tv1.x * PROJECTION_DISTANCE) / tv1.z) + SCREEN_WIDTH/2;
            int y1 = (int)((-tv1.y * PROJECTION_DISTANCE) / tv1.z) + SCREEN_HEIGHT/2;
            int x2 = (int)((tv2.x * PROJECTION_DISTANCE) / tv2.z) + SCREEN_WIDTH/2;
            int y2 = (int)((-tv2.y * PROJECTION_DISTANCE) / tv2.z) + SCREEN_HEIGHT/2;
            int x3 = (int)((tv3.x * PROJECTION_DISTANCE) / tv3.z) + SCREEN_WIDTH/2;
            int y3 = (int)((-tv3.y * PROJECTION_DISTANCE) / tv3.z) + SCREEN_HEIGHT/2;
            
            // Check if any part of triangle is on screen
            if((x1 < 0 && x2 < 0 && x3 < 0) || 
               (x1 > SCREEN_WIDTH && x2 > SCREEN_WIDTH && x3 > SCREEN_WIDTH) ||
               (y1 < 0 && y2 < 0 && y3 < 0) || 
               (y1 > SCREEN_HEIGHT && y2 > SCREEN_HEIGHT && y3 > SCREEN_HEIGHT)) {
                continue;
            }
            
            // Draw wireframe triangle
            canvas_draw_line(canvas, x1, y1, x2, y2);
            canvas_draw_line(canvas, x2, y2, x3, y3);
            canvas_draw_line(canvas, x3, y3, x1, y1);
        }
    }
}

int32_t p1x_smol_teapot_app(void* p) {
    UNUSED(p);
    FURI_LOG_I("P1X_SMOL_TEAPOT", "3D Teapot renderer starting");
    
    // Create event queue
    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));
    
    // Set up state
    TeapotState* state = malloc(sizeof(TeapotState));
    state->mutex = furi_mutex_alloc(FuriMutexTypeNormal);
    
    // Set up viewport
    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, render_callback, state);
    view_port_input_callback_set(view_port, input_callback, event_queue);
    
    // Register viewport with GUI
    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);
    
    // Initialize timing
    last_frame_time = furi_get_tick();
    current_triangle_batch = 0;
    
    // Handle events
    InputEvent event;
    bool running = true;
    
    while(running) {
        // Rate limit updates to prevent freezing
        uint32_t current_time = furi_get_tick();
        bool frame_ready = (current_time - last_frame_time >= FRAME_INTERVAL);
        
        // Process input with timeout
        FuriStatus event_status = furi_message_queue_get(event_queue, &event, frame_ready ? 0 : FRAME_INTERVAL);
        
        if(event_status == FuriStatusOk) {
            if(furi_mutex_acquire(state->mutex, 100) == FuriStatusOk) {
                // Process key presses
                if(event.type == InputTypePress || event.type == InputTypeRepeat) {
                    switch(event.key) {
                        case InputKeyUp:
                            rotation.x += 0.25f;
                            break;
                        case InputKeyDown:
                            rotation.x -= 0.25f;
                            break;
                        case InputKeyLeft:
                            rotation.y -= 0.25f;
                            break;
                        case InputKeyRight:
                            rotation.y += 0.25f;
                            break;
                        case InputKeyOk:
                            rotation.x = 0;
                            rotation.y = 0;
                            rotation.z = 0;
                            break;
                        case InputKeyBack:
                            running = false;
                            break;
                        default:
                            break;
                    }
                }
                
                furi_mutex_release(state->mutex);
            }
            
            // Force redraw after input
            if(event.type == InputTypePress || event.type == InputTypeRepeat) {
                view_port_update(view_port);
            }
        }
        
        // Update display at controlled frame rate
        if(frame_ready) {
            view_port_update(view_port);
            last_frame_time = current_time;
        } else {
            // Give some time back to the system
            furi_delay_ms(10); // Increased delay for better system responsiveness
        }
    }
    
    // Clean up
    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    furi_record_close(RECORD_GUI);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);
    furi_mutex_free(state->mutex);
    free(state);
    
    return 0;
}
